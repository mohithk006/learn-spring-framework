Configuration Comparison: XML vs. Annotation (Java Config)
The Fundamental Difference
XML Configuration (Classic Spring): The instruction manual for the Spring Context is written in a separate,
external XML file. Configuration is entirely separate from the Java code.

Annotation Configuration (Modern Spring Boot): The instruction manual is written directly inside the Java code
using special annotations (@Configuration, @Bean, @Component).
----------------------------------------------------------------------------------------------------------------------
Object Creation and Wiring
XML Way (The <bean> Tag):
Objects (Beans) are defined using the verbose <bean> tag, specifying the class name as a string attribute.

Dependencies are injected using sub-tags like <constructor-arg> or <property>.
----------------------------------------------------------------------------------------------------------------------
Annotation Way (The @Bean / @Component):

Objects are defined by putting simple annotations (@Component, @Service, etc.) directly on the class.

Dependencies are injected using the @Autowired annotation on fields or constructors.
----------------------------------------------------------------------------------------------------------------------
Maintainability and Safety
Type Safety (Major Weakness of XML):

XML: Configuration errors (like misspellings of class names, or passing the wrong data type) are found only at
runtime (when the application starts). This is slow and risky.

Annotations: Errors are found immediately by the Java Compiler (compile-time error), thanks to strong type checking.
This is fast and safe.
----------------------------------------------------------------------------------------------------------------------
Refactoring:

XML: If you rename a class or method in your Java code, you must manually update every reference to that old name
inside the XML file.

Annotations: The Java compiler handles renaming automatically, ensuring all dependency names are updated
(this is a massive benefit).
----------------------------------------------------------------------------------------------------------------------
Location:

XML: Configuration is centralized, but you constantly have to switch between your Java logic files and the large,
separate XML file to see whatâ€™s connected to what.

Annotations: Configuration lives right alongside the class it affects, making it clear what its role and
dependencies are.
----------------------------------------------------------------------------------------------------------------------
Modern Usage
XML Configuration: Is now considered legacy. It is primarily used for maintaining existing, older enterprise
applications or for highly specific, complex configuration setups like security rules.

Annotation/Java Configuration: Is the modern standard for all new Spring and Spring Boot development. It is cleaner,
faster to write, and far safer to maintain.
----------------------------------------------------------------------------------------------------------------------
Context Creation
XML Config -> var context = new ClassPathXmlApplicationContext("file-location-path");
Annotation Config -> var context = new AnnotationConfigApplicationContext(LauncherClassName.class);
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
XML CONFIG EXAMPLE:

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/
                                                                            schema/beans/spring-beans.xsd">

                <!--
                    1. BEAN CREATION: Creating ComponentB
                    (This is the XML equivalent of @Component or @Bean)
                -->
    <bean id="componentB" class="your.package.ComponentB"/>


                <!--
                    2. BEAN CREATION and INJECTION: Creating ServiceA and wiring ComponentB
                    (This is the XML equivalent of @Component + @Autowired on the constructor)
                -->
    <bean id="serviceA" class="your.package.ServiceA">

                <!--
                    The <constructor-arg> tag tells Spring:
                    "When you create ServiceA, find the Bean with the reference 'componentB'
                     and pass it into the constructor."
                -->
        <constructor-arg ref="componentB" />

    </bean>

</beans>

----------------------------------------------------------------------------------------------------------------------
ANNOTATION APPLICATION CONTEXT EXAMPLE:


import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// =======================================================
// A. APPLICATION CLASSES (The components to be managed)
// =======================================================

// 1. ComponentB: The Dependency
// (No Spring annotations needed here)
class ComponentB {
    public String getInfo() {
        return "Info from Component B (The Database Connector)";
    }
}

// 2. ServiceA: The Consumer that needs ComponentB
class ServiceA {
    private ComponentB dependency;

    // This constructor IS the injection point.
    // Spring sees this and knows to supply the 'ComponentB' Bean.
    public ServiceA(ComponentB dependency) {
        this.dependency = dependency;
    }
}


// =======================================================
// B. CONFIGURATION (The Direct XML Replacement)
// =======================================================

@Configuration // <--- This tag replaces the entire <beans> XML file structure
public class AppConfig {

    // 1. BEAN DEFINITION for ComponentB
    // Equivalent to: <bean id="componentB" class="..."/>
    @Bean
    public ComponentB componentB() {
        System.out.println("Config: Creating ComponentB Bean.");
        return new ComponentB();
    }

    // 2. BEAN DEFINITION & WIRING for ServiceA
    // Equivalent to: <bean id="serviceA" class="..."><constructor-arg ref="componentB" /></bean>
    @Bean
    // Spring sees the parameter (ComponentB componentB) and knows to look up
    // the Bean created above and pass it into the constructor for ServiceA.
    public ServiceA serviceA(ComponentB componentB) {
        System.out.println("Config: Creating ServiceA Bean and Injecting componentB.");
        return new ServiceA(componentB);
    }
}
